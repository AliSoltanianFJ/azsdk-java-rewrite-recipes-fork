<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeReferenceRecipe.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rewrite-java-core</a> &gt; <a href="index.source.html" class="el_package">com.azure.recipes.core.v2</a> &gt; <span class="el_source">TypeReferenceRecipe.java</span></div><h1>TypeReferenceRecipe.java</h1><pre class="source lang-java linenums">package com.azure.recipes.core.v2;

import org.jetbrains.annotations.NotNull;
import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Recipe to convert TypeReference to ParameterizedType and remove TypeReference import statements.
 * --------------------------------------------------
 * Before applying this recipe:
 * import com.azure.core.util.serializer.TypeReference;
 * ...
 *  result = binaryDataResponse.getValue().toObject(new TypeReference&lt;List&lt;TranslatedTextItem&gt;&gt;() { });
 * --------------------------------------------------
 * After applying this recipe:
 * import java.lang.reflect.ParameterizedType;
 * import java.lang.reflect.Type;
 * ...
    result = binaryDataResponse.getValue().toObject(new ParameterizedType() {
    @Override
    public Type getRawType() {
    return List.class;
    }

    @Override
    public Type[] getActualTypeArguments() {
    return new Type[]{TranslatedTextItem.class};
    }

    @Override
    public Type getOwnerType() {
    return null;
    }
    });
 * --------------------------------------------------
 * @author Ali Soltanian Fard Jahromi
 */
<span class="fc" id="L49">public class TypeReferenceRecipe extends Recipe {</span>

    @Override
    public @NotNull String getDisplayName() {
<span class="fc" id="L53">        return &quot;Convert TypeReference to ParameterizedType and remove imports&quot;;</span>
    }

    @Override
    public @NotNull String getDescription() {
<span class="fc" id="L58">        return &quot;This recipe converts TypeReference&lt;&gt; to ParameterizedType and removes the import statement for TypeReference.&quot;;</span>
    }

    @Override
    public @NotNull TreeVisitor&lt;?, ExecutionContext&gt; getVisitor() {
<span class="fc" id="L63">        return new ConvertTypeReferenceVisitor();</span>
    }

<span class="fc" id="L66">    private static class ConvertTypeReferenceVisitor extends JavaIsoVisitor&lt;ExecutionContext&gt; {</span>
        /**
         * Method to visit instantiation of TypeReference and replace it with ParameterizedType
         * instantiation including override methods.
         * */
        @Override
        public J.@NotNull NewClass visitNewClass(J.@NotNull NewClass newClass, @NotNull ExecutionContext ctx) {
<span class="fc" id="L73">            J.NewClass visitedNewClass = super.visitNewClass(newClass, ctx);</span>

            // Check if the TypeReference reference has already been transformed
<span class="fc bfc" id="L76" title="All 2 branches covered.">            if (visitedNewClass.getBody() == null){return visitedNewClass;}</span>
<span class="fc" id="L77">            boolean alreadyTransformed = visitedNewClass.getBody().getStatements().stream()</span>
<span class="fc" id="L78">                    .filter(statement -&gt; statement instanceof J.MethodDeclaration)</span>
<span class="fc" id="L79">                    .map(J.MethodDeclaration.class::cast)</span>
<span class="fc" id="L80">                    .anyMatch(methodDeclaration -&gt; methodDeclaration.getName().getSimpleName().equals(&quot;getRawType&quot;));</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (visitedNewClass.getClazz() == null){return visitedNewClass;}</span>
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">            if (!alreadyTransformed &amp;&amp; visitedNewClass.getClazz().toString().contains(&quot;TypeReference&quot;)) {</span>
                // Extract type from generic type in TypeReference declaration
<span class="fc" id="L84">                String genType = null;</span>
<span class="fc" id="L85">                String type = null;</span>
<span class="fc" id="L86">                String type2 = null;</span>
<span class="fc" id="L87">                List&lt;JavaType&gt; fullType = null;</span>


<span class="pc bpc" id="L90" title="1 of 2 branches missed.">                if(visitedNewClass.getClazz().getType() != null){</span>
                    try {
<span class="fc" id="L92">                        fullType = ((JavaType.Parameterized) visitedNewClass.getClazz().getType()).getTypeParameters();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                        if (fullType.get(0) instanceof JavaType.Parameterized) { // Check if using parameterized type</span>
<span class="fc" id="L94">                            type = ((JavaType.Class)((JavaType.Parameterized) fullType.get(0)).getTypeParameters().get(0)).getClassName();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                            if (((JavaType.Parameterized) fullType.get(0)).getTypeParameters().size() &gt; 1) {</span>
<span class="fc" id="L96">                                type2 = ((JavaType.Class)((JavaType.Parameterized) fullType.get(0)).getTypeParameters().get(1)).getClassName();</span>
                            }
<span class="fc" id="L98">                            genType = ((JavaType.Parameterized) fullType.get(0)).getClassName();</span>
                        } else {
<span class="fc" id="L100">                            genType = ((JavaType.Class)fullType.get(0)).getClassName();</span>
                        }
<span class="nc" id="L102">                    } catch (ClassCastException e) { // OpenRewrite has a bug where parameterized new-classes contained in method arguments can't be parsed, so extract type information using String manipulation instead</span>
<span class="nc" id="L103">                        genType = visitedNewClass.getClazz().toString().split(&quot;&lt;&quot;)[1];</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                        if (visitedNewClass.getClazz().toString().contains(&quot;,&quot;)) {</span>
<span class="nc" id="L105">                            type = visitedNewClass.getClazz().toString().split(&quot;&lt;&quot;)[2].replace(&quot;&gt;&quot;, &quot;&quot;).split(&quot;,&quot;)[0];</span>
<span class="nc" id="L106">                            type2 = visitedNewClass.getClazz().toString().split(&quot;&lt;&quot;)[2].replace(&quot;&gt;&quot;, &quot;&quot;).split(&quot;,&quot;)[1];</span>
                        }else {
<span class="nc" id="L108">                            type = visitedNewClass.getClazz().toString().split(&quot;&lt;&quot;)[2].replace(&quot;&gt;&quot;, &quot;&quot;);</span>
                        }
<span class="fc" id="L110">                    }</span>
                }
<span class="fc" id="L112">                JavaTemplate methodRawTypeTemplate = JavaTemplate.builder(&quot;@Override public Type getRawType() { return &quot; + extractTypeArgument(visitedNewClass.toString()) + &quot;.class; }&quot;).build();</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if (genType!=null){</span>
<span class="fc" id="L114">                    methodRawTypeTemplate = JavaTemplate.builder(&quot;@Override public Type getRawType() { return &quot; + genType + &quot;.class; }&quot;).build();</span>
                }
<span class="fc" id="L116">                JavaTemplate methodActualTypeTemplate = JavaTemplate.builder(&quot;@Override public Type[] getActualTypeArguments() { return new Type[] {}; }&quot;).build();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">                if (type != null){</span>
<span class="fc" id="L118">                    methodActualTypeTemplate = JavaTemplate.builder(&quot;@Override public Type[] getActualTypeArguments() { return new Type[] {  &quot; + type + &quot;.class  }; }&quot;).build();</span>
                }
<span class="fc" id="L120">                JavaTemplate methodOwnerTypeTemplate = JavaTemplate.builder(&quot;@Override public Type getOwnerType() { return null; }&quot;).build();</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (type2 != null){ // If TypeReference uses Map&lt;T,V&gt; or any other class with the same structure like Foo&lt;T,V&gt;</span>
<span class="fc" id="L122">                    methodActualTypeTemplate = JavaTemplate.builder(&quot;@Override public Type[] getActualTypeArguments() { return new Type[] {  &quot; + type + &quot;.class,&quot; + type2 + &quot;.class  }; }&quot;).build();</span>
                }
                // Apply Templates (add methods to body)

<span class="fc" id="L126">                visitedNewClass = visitedNewClass.withBody(methodRawTypeTemplate.apply(new Cursor(getCursor(), visitedNewClass.getBody()),</span>
<span class="fc" id="L127">                        visitedNewClass.getBody().getCoordinates().lastStatement()));</span>
<span class="fc" id="L128">                visitedNewClass = visitedNewClass.withBody(methodActualTypeTemplate.apply(new Cursor(getCursor(), visitedNewClass.getBody()),</span>
<span class="fc" id="L129">                        visitedNewClass.getBody().getCoordinates().lastStatement()));</span>
<span class="fc" id="L130">                visitedNewClass = visitedNewClass.withBody(methodOwnerTypeTemplate.apply(new Cursor(getCursor(), visitedNewClass.getBody()),</span>
<span class="fc" id="L131">                        visitedNewClass.getBody().getCoordinates().lastStatement()));</span>

<span class="fc" id="L133">                visitedNewClass = visitedNewClass.withClazz(TypeTree.build(&quot; ParameterizedType&quot;)); // Replace TypeReference with Type</span>

            }
<span class="fc" id="L136">            return visitedNewClass;</span>
        }

<span class="fc" id="L139">        private final Set&lt;String&gt; importSet = new HashSet&lt;&gt;();</span>

        @Override
        public J.@NotNull Import visitImport(J.@NotNull Import importStmt, @NotNull ExecutionContext ctx) {
<span class="fc" id="L143">            String importQualid = importStmt.getQualid().toString();</span>

            // Add the import to the set and check if it already exists
<span class="fc" id="L146">            boolean isNewImport = importSet.add(importQualid);</span>

            // If the import is for ParameterizedType, and it's already in the set, skip it
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">            if (importQualid.trim().equals(&quot;java.lang.reflect.ParameterizedType&quot;) &amp;&amp; !isNewImport) {</span>
<span class="nc" id="L150">                return null;</span>
            }

            // Remove the import statement for TypeReference and add import for ParameterizedType
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (importQualid.equals(&quot;com.azure.core.util.serializer.TypeReference&quot;)) {</span>
<span class="fc" id="L155">                importSet.add(&quot;java.lang.reflect.ParameterizedType&quot;);</span>
<span class="fc" id="L156">                return importStmt.withQualid(TypeTree.build(&quot; java.lang.reflect.ParameterizedType&quot;));</span>
            }

            // Change BinaryData import to a new package
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (importQualid.equals(&quot;com.azure.core.util.BinaryData&quot;)) {</span>
<span class="fc" id="L161">                importSet.add(&quot;io.clientcore.core.util.binarydata.BinaryData&quot;);</span>
<span class="fc" id="L162">                return importStmt.withQualid(TypeTree.build(&quot; io.clientcore.core.util.binarydata.BinaryData&quot;));</span>
            }

            // Return other imports normally
<span class="fc" id="L166">            return importStmt;</span>
        }
        /**
         * Method to visit variable declaration for TypeReference and make sure it is converted to java.lang.reflect.Type
         */
        @Override
        public J.@NotNull VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext executionContext) {
<span class="fc" id="L173">            J.VariableDeclarations visitedDeclarations = super.visitVariableDeclarations(multiVariable, executionContext);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (visitedDeclarations.toString().contains(&quot;TypeReference&quot;)</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                    &amp;&amp; visitedDeclarations.toString().contains(&quot;ParameterizedType&quot;)) {</span>
<span class="fc" id="L176">                visitedDeclarations = visitedDeclarations.withTypeExpression(TypeTree.build(&quot; Type&quot;));</span>
<span class="fc" id="L177">                return visitedDeclarations;</span>
            }
<span class="fc" id="L179">            return visitedDeclarations;</span>
        }

        /**
         * Method to visit BinaryData type and change it to the new version
         */
        @Override
        public J.@NotNull FieldAccess visitFieldAccess(J.@NotNull FieldAccess fieldAccess, @NotNull ExecutionContext ctx) {
<span class="fc" id="L187">            J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);</span>
<span class="fc" id="L188">            String fullyQualified = fa.getTarget() + &quot;.&quot; + fa.getSimpleName();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (fullyQualified.equals(&quot;com.azure.core.util.BinaryData&quot;)) {</span>
<span class="fc" id="L190">                return TypeTree.build(&quot; io.clientcore.core.util.binarydata.BinaryData&quot;);</span>
            }
<span class="fc" id="L192">            return fa;</span>
        }

        /**
         * Method to add import for java.lang.reflect.Type if needed
         */
        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext executionContext) {
<span class="fc" id="L200">            J.CompilationUnit visitedCompilationUnit = super.visitCompilationUnit(cu, executionContext);</span>
<span class="fc" id="L201">            J.Import newImport = null;</span>
<span class="fc" id="L202">            boolean addTypeImport = false;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (visitedCompilationUnit.getImports().isEmpty()){return visitedCompilationUnit;}</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            for (J.Import i : visitedCompilationUnit.getImports()) {</span>
<span class="fc" id="L205">                newImport = i;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                if (i.toString().contains(&quot;java.lang.reflect.Type&quot;)){</span>
<span class="fc" id="L207">                    return visitedCompilationUnit;</span>
                }
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (i.toString().contains(&quot;java.lang.reflect.ParameterizedType&quot;)){</span>
<span class="fc" id="L210">                    addTypeImport = true;</span>
                }
<span class="fc" id="L212">            }</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (addTypeImport) {</span>
<span class="fc" id="L214">                newImport = newImport.withQualid(TypeTree.build(&quot; java.lang.reflect.Type&quot;));</span>
<span class="fc" id="L215">                List&lt;J.Import&gt; imports = visitedCompilationUnit.getImports();</span>
<span class="fc" id="L216">                imports.add(newImport);</span>
<span class="fc" id="L217">                return visitedCompilationUnit.withImports(imports);</span>
            }
<span class="fc" id="L219">            return visitedCompilationUnit;</span>
        }

        public String extractTypeArgument(String text) {
            // Find the start and end of the type argument
<span class="fc" id="L224">            int startIndex = text.indexOf('&lt;');</span>
<span class="fc" id="L225">            int endIndex = text.indexOf('&gt;', startIndex);</span>

<span class="pc bpc" id="L227" title="2 of 4 branches missed.">            if (startIndex == -1 || endIndex == -1) {</span>
<span class="nc" id="L228">                return null; // If '&lt;' or '&gt;' not found, return null</span>
            }

            // Extract the substring between the angle brackets
<span class="fc" id="L232">            return text.substring(startIndex + 1, endIndex).trim();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>